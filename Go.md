# Go

[toc]

## Начало работы с GO
[Документация](http://golang.org/pkg)
### Характеристики

Императивный
Нет классов, но есть структуры и интерфейсы
Нет наследования, но есть встраивание (mixins)
Функции - объекты 1-го класса
Есть замыкания
Конкурентность
Функции могут возвращать более 1 значения
Конкурентность
Всегда собирается в 1 бинарный файл

### Структура проекта

|-go

|--bin # тут лежат скомпилированные бинарными

|--pkg # промежуточные файлы

|--src # исходные файлы

### Основные синтаксические конструкции

#### Объявление функции

```go
package main # объявление проекта

func main() {
    println("hello, world!")
}
```

* так же это точка входа

#### импортирование пакетов

```go
package main

import (  # импорт пакетов
    "fmt"
)

func main() {
    fmt.println('hello, world!')
}
```

- для многострочного сообщения используются обратные кавычки (``)

#### объявление переменной

```go
var a int = 5 # ключевое слово var <имя переменной> <тип переменной> = <значение переменной>

c := 7 # краткий синтаксис
d,e,f := 1, 2, 3 
```

- если **не нужен** специальный тип, лучше использовать :=
- глобальные переменные объявляются только через var
- неинициализированных переменных не бывает, для записи var q int
  переменной q будет присвоено значение 0

#### константы

```go
const(
    a int = 1
    b string = "hello, world!"
)
```

- константы могут быть не типизированными

- `iota`  преодпределенная константа, которая устанавливает первое значение в 0, а последующие в 1, 2, 3 и т.д. обычно используется для создания `enum`

  ```go
  const (
      a = iota # 0
      b		 # 1
      c		 # 2	
  )
  ```

- _  - пустой идентификатор

#### условный оператор if

```go
if a > b {
    //do something
} else {
    // do something else
}

if a,b := 5, 7; a > b { # присвоение внутри оператора
    // do something
}
```

- присваивание внутри оператора обычно используется как обработки ошибок

  ```go
  if err := dosome(); err != nil {
      //handle error
  }
  ```

#### цикл for

```go
for i < 10 { # замена while
    //do something
    i++
}

for { # вечный цикл
    // do something 
    i++
    if (i > 10) {
        break # еще есть continue
    }
}

a := [...]int{81, 54, 43, 66}
for index, value := range a {
    //do something
}
```

- других циклов нет

#### конструкция switch

```go
switch a {
    case 10:
    	//do something
    default:
    	//do default
}
switch a {
    case 10:
    	//do something
    	fallthrought # проваливание
    case 20:
    	//do something
    	fallthrought
    default:
    	//do default
}
```

- `break ` - писать не нужно
- `fallthrought` - позволяет перейти к следующему `case`

### инструментарий

#### инфраструктура языка

##### единое дерево кода

###### goroot и gopath

**`gopath`** - переменная, которая сообщает, где содержатся исходники

**`goroot`** - путь где лежат исходники самого языка

плюсы:

- простота. плоская структура.
- отсутствие версий

минусы:

- отсутствие версий
- иногда в проекте не только go-код

##### модули (go modules)

начиная c go 1.11 появилась поддержка модулей
модуль любая директория содержащая файл go.mod (любая директория вне gopath)

**`go.mod`** - файл, по которому go понимает что данная директория - модуль.

```bash
go mod init <путь репозитория> #инициализирует модуль, создаст файл go.mod
```

внутри модуля команды `go get` скачивает и фиксирует версии пакетов.
внутри файла `go.mod` - содержатся информации о зависимостях модуля.
внутри модуля будет файл `go.sum`, который содержит чек-суммы зависимостей.

###### как управлять зависимостями при разработке

в импорте пакета:

```go
package main

import (
    "fmt"
    "github.com/go/loremipsum"
)
```

затем запустить:

```bash
go mod tidy #смотрит на импорты и обновляет зависимости
```



##### go get

скачивает пакет

- `https://` - писать не нужно. например: `github.com/golang/protobuf`

`go get` - скачает и установит
`go get -d`- скачать но не устанавливать. обычно не используется.
многоточие `...` например `github.com/golang/protobuf/...`, означает что нужно скачать все зависимости пакета.

- вообще `...` это сделать что-то рекурсивно

`go get -u` обновит пакет

##### go build

собирает точечно собирает пакет. в большинстве случаев следует использовать `go install`. но `go build` всегда пересобирает пакет.

##### go install

компилирует указанный пакет и устанавливает его. переносит в `$gopath/pkg`
исполняемый файл будет помещен в `$gopath/bin`
сохраняет все промежуточные пакеты.

#### кросс-компиляция

go может скомпилировать файл для разных ос и архитектур. для этого при сборке нужно переопределить переменные `goos` и `goarch`

```bash
goarch=386 goos=darwin go build -o /tmp/protobuff github.com/golang/protobuf/...
```

возможные значения можно посмотреть [значения goos и goarch ](https://gist.github.com/asukakenji/f15ba7e588ac42795f421b48b8aede63)

#### одиночный запуск

```bash
go run <path/to/file.go> #запустит файл, можно проверить синтаксис и работу кода
```

#### форматирование кода (gofmt)

```bash
go fmt <path/to/file> # форматирует файл согласно стандарту
```

#### форматирование импортов (внешняя надстройка над gofmt) goimports

[устанока и документация](https://godoc.org/golang.org/x/tools/cmd/goimports)

следит за импортами добавляет / удаляет нужные.

#### линтеры

##### go vet

встроенный линтер

##### golint

сторонний линтер https://github.com/golang/lint

##### мета-линтер golangci-lint

агрегатор линтеров - https://golangci-lint.run управляет сторонними лихтерами, может запускать цепочки линтеров.

#### тестирование

файлы с тестами должны быть названы специальным синтаксисом <пакет>_test.go
в данном файле содержатся тесты для пакета. данные файлы участвуют только в тестировании.

##### unit-тесты

следует писать unit-тесты для функциональности, т.е. тестируется отдельная функциональность, а не полная инфраструктура

пример:

```go
# основной пакет foobar
package foobar

func count(s string, r rune) int {
    var cnt int
    for _, l %= range s {
        if l == r {
            cnt += 1
        }
    }
    
    return cnt
}


# foobar/count_test.go

package foobar #тесты пакета в том же пакете

import "testing"

#тестом является любая функция со слова test
#такая функция должна принимать аргумент t * testing.t
func testcount (t *testing.t) { 
    s := "qweqwe"				
    e := 2
    if c := count(s, 'e'); c != e {
        t.fatalf("bad count for %s: got %d expected %d", s, c, e) # будет вызвано при непрохождении теста
    }
}
```

 запуск тестов:

```bash
go test # тесты в текущей директории
go test github.com/gorilla/mux # тесты произвольного пакета
go test google.golang.org/grpc/... # тесты включая вложенные пакеты
```

##### пакет testing

t.fail() // отметить тест как сломанный, но продолжить выполнение

t.failnow() // отметить тест как сломаный и прекратить текущий тест

t.logf(formar string, ...interface{}) // вывести сообщение с отладкой

**t.errorf(formar string, ...interface{})** // t.log + t.fail

**t.fatalf(formar string, ...interface{})** // t.log + t.failnow

t.skipnow() // пропустить тест

##### пакет [testify](https://github.com/stretchr/testify)

пакет содержит дополнительные инструменты для тестирования, расширяющие стандартный **testing**

##### best practices тестирования

- тесты должны быть достоверными и исерпывающими
  тесты должны ломаться, только тогда, когда действительно не работает код
- тесты - это тоже код
- один тест - один тестовый случай
  на 1 библиотечную функцию 1 тест, но иногда имеет смысл разбить тест на отдельные сценарии
- тесты должны быть изолированы
  следует избегать веерных поломок тестов
- тесты должны обрабатывать быстро
- тесты не должны использовать результаты другого теста
- не следует выводить diff для сравнения глазами
- избегать слишком большого количества проверок в 1 тесте
- не следует иметь зависимости от внешних файлов (вне репозитория)
- следует избегать неполного тестирования (если покрывать тестами - то все)

### элементарные типы данных

#### объявление переменных в go

```go
var storage map[string]string // zero value

# все что начинается с большой буквы - экспортируемое (видно в других пакетах)
# маленькая буква - private

var storage = make(map[string]string) // автовывод типа
#в полном варианте должно было быть var storage map[string]string = make(map[string]string)

var some = 3 // автовывод типа

# func <название>() <возвращаемый тип>
func answer() int {
    return 42
}

func main() {
    # локальные переменные
    var i int = 10
    j := i // короткое объявление, только внутри функций, глобальные функции так указывать нельзя
}
```

##### публичные и приватные идентификаторы

публичные идентификаторы - те, которые видны за пределами пакета. публичные идентификаторы начинаются с заглавной буквы

приватные идентификаторы - начинаются со строчной буквы и видны только внутри пакета.

структуры могут содержать как приватные так и публичные поля.

```go
type user struct {
    name	 string
    password string
}
```

#### целые типы

`int`, `uint`, `uint8` и т.д. подробнее в [документации](https://golang.org/ref/spec#numeric_types)

к некоторым типам есть алиасы:

`byte` = `uint8`
`rune` = `int32`

всегда есть значение "по умолчанию" = 0
типы int и uint могут принимать значения 32 и 64 бита на разных платформах.
**нет автоматического преобразования типов.**

#### с плавающей точкой

`float32`
`float64`

#### комплексные числа

`complex64`, `complex128`

#### строки (неизменяемая последовательность байт!)

[документация](https://blog.golang.org/strings)

```go
# внутренняя структура строки
type stringstruct struct {
    str unsafe.poinet
    len int
}
```

`byte = uint8`

`string`



##### строковые литералы

```go
s := "hello, world!" # в двойных кавычках, на одной строке
s := 'hello \n world \u9333' # в одинарных кавычках с непечатными символами

// если нужно включить в строку кавычки или переносы строк
s := `hello
"cruel"
'world'
`
```

##### действия со строками

```go
s := "hello world" // создает строку
var c byte = s[0] // получить доступ к байту(!) в строке
var s2 string = s[5:10] // получить подстроку в байтах(!)
var := s + "again" // конкатенация - очень дорогая операция в go
l := len(s) // узнать количество байт в строке


```

**устройство  unicode в  go**

исходники go  и все литералы - в кодировке  utf-8

как устроен utf-8

utf-8 - многобайтовая

(подробнее в устройстве [utf-8](https://habr.com/ru/post/113715/))

`z`= `5a`

`я` = `do af`

символы unicode в go  представлены с помощью типа `rune` = `int32`
литералы рун выглядят так:
```go
var r rune = 'я'
var r rune = '\n'
var r rune = '\xff' // последовательность байт
var r rune = '\u12e4' //unicode code-point
```
руны это целые числа, поэтому их можно складывать

для работы с unicode и utf-8 используется пакет `unicode` и `unicode/utf8'
```go
// получить первую руну из строки и ее размер в байтах
decoderuneinstring(s string) (r rune, size int)

// получить длинну строки в рунах
runecountinstring(s string) (n int)

// проверить валидность строки
validstring(s string) bool
```

строку всегда можно преобразовать в `slice` и работать далее со слайсом 

```go
s := "привет"
ba := []byte(s)
ra := []rune(s)
fmt.printf("% v/n/b", ra)
fmt.printf("% v/n/b", ba)
```
итерация по строкам:
```go
for i:= 0; i < len(s); i++ {
	b := s[i]
	// i строго последовательно
	// b имеет тип byte, uint8
}
```

итерация по рунам:
```go
for i, r := range s {
	// i может перепрыгивать значения 
	// r имеет тип rune, int32
```
в go есть общирная библиотека для работы со строками - пакет `strings`

```go
// проверка наличия подстроки
contains(s, substr string) bool

// строка начинается с ?
hasprefix(s, prefix string) bool

// разбиение по разделителю
split(s, sep string) bool
```
для склейки строк лучше использовать `strings.builder` так как конкатенация требует много памяти

```go
import "strings"

var b strings.builder
for i := 33, i >= 1; i-- {
	b.writestring("код")
	b.writerune("ъ")
}
result := b.string()
```
#### константы

константы - неизменяемые значения, доступные только во время компиляции.
```go
const pi = 3	// принимает подходящий тип
const pi float32 = 3.14
const (
	thea = 1
	theb = 2
)

const (
	x = iota // 0
	y	 // 1
	z	 // 2
)
```
##### как работать с iota
`iota` -  используется для инкрементных значений констант
```go

const (
        x = 2
        y
        z
)

//попробуем вывести значения
func main() {
    fmt.printf("%d %d %d", x, y, z) 
}

>>> 2 2 2

const(
    x = iota // инкрементное значение начиная с 0
    y
    z
)

func main() {
    fmt.printf("%d %d %d", x, y, z)
}

>>> 0 1 2
```
для того чтобы инкрементировать с 1 применяют нулевой идентификатор `_`
```go

const (
    _ = iota
    x
    y
    z
)
```
для `iota` можно искользовать арифметические и побитовые операции или задать формулу (iota + 3 * 3)
```go

conts(
    _ = iota * 2
    x   // 2 
    y   // 4
    z   // 6
)
```
#### массивы
тип [n]t обозначает массив из `n` значений типа `t`
выражение ` var a [10]int` объявляет переменную  `a` как массив из 10 целых числел.
размер (длинна) массива является частью типа поэтому размаер массива не может быть изменен.

```go
package main

import (
    "fmt"
)

func main() {
    var a [2]string
    a[0] = "hello" //  внесение данных в первый элемент массива
    a[1] = "world"

    fmt.println(a[0], a[1]) // обращение к элементам массива
    fmt.println(a)

    b := [10][10]string // многомерный массив
    primes := [6]int{2, 3, 5, 7, 11, 13} // объявление массива и его заполнение при создании
    fmt.println(primes)
```

#### Слайсы 

в отличии от массивов срез - гибкое отображение элементова массива с возможностью динамического изменения размераю на практике срезы более распространены, чем массивы.

тип []t обозначает срез с элементами типа т.

```go
package main
import (
    "fmt"
)

func main() {
    primes := [6]int{2, 3, 5, 7, 11, 13}

    var s []int = primes[1:4]
    fmt.println(s)
```
срез не хранить никаких данных. срез - указатель на секцию нижележащего массива. изменение элемента среза приведет к изменению элемента в массиве.
~
литерал среза точно такой же как и у массива, но без указания размера

```go

[]bool{true, false, true} // в данном случае будет создан массива из 3-х элементов и срез, как указатель на этот массив.
```

значения по умолчанию для срезов это 0 и размерность среза.
```go

// для массива 
var a[10]int

//  следующие выражения создания срезы эквивалентны:
a[0:10]
a[:10]
a[0:]
a[:]
```

срез имеет длинну и вместимость (length, capacity)
размер(длинна) среза - это количество элементов, которые он содержит.д
вместимость среза - это количество элементов в его ниэележащем массиве, начиная с первого элемента в срезе.  
размер и вместимость могут быть получены с помощью len(s) и cap(s), где `s` срез. (слайс)

размер среза(слайса) может быть увеличен путем повторной операции "срезания", при условии, что он обладает достаточной вместимостью.

слайсы могут быть созданы с помощью функции `make`

```go

a := make([]int, 5) // len(a) = 5

//  чтобы указать вместимость, необходимо указать третий аргумент

b := make([]int, 0, 5) // len(b) = 5, cap(b) = 5
```
слайсы могут содержать любые типы, в том чилсе и другие слайсы

```go
package main

import (
    "fmt"
    "strings"
)

func main() {
    board := [][]string { // слайс содержит другие слайсы с элементами тпа string
        []string{"_", "_", "_"},
        []string{"_", "_", "_"},
        []string{"_", "_", "_"},
    }

    board[0][0] = "x"
    board[2][2] = "o"
    board[1][2] = "x"
    board[1][0] = "o"
    board[0][2] = "x"

    for i := 0; i < len(board); i++ {
        fmt.printf("%s\n", strings.join(board[i], " " ))
    }
}
```

для добавления к слайсу можно использовать функцию [append](https://golang.org/pkg/builtin/#append)

```go
package main

import (
    "fmt"
)

func main() {
    var s []int // len=0 cap=0 []
    
    // добавляем в nil слайс
    s = append(s, 0) // len=1 cap=1 [0]
    
    // если будет необходимо, то вместимость слайса будет расширена
    s = append(s, 1) // len=2 cap=2 [0, 1]

    // за 1 раз можно добавлять более одного элемента
    s = append(s, 2, 3, 4) // len=5 cap=6 [0 1 2 3 4]
    
    // можно добавить 1 слайс в конец другого
    s = append(s, s2...)
```

итерация по срезам происходит помощью `for` и ключевого слова `range`
```go
package main

import (
    "fmt"
)

var pow = []int{1, 2, 4, 8, 16, 32, 64, 128}

func main() {
    for i, v := range(pow) { // range возвращает 2 значения: индекс и значение
        fmt.printf("2**%d = %d\n", i, v)
    }
}
```
получение под-слайсов ( нарезка слайсов)

`s[i:j]` - возвращает под-слайс, с i-того элемента включительно, по j-й элемент не включительно.
длинна слайса будет: j-i

```go
s := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}

s2 := s[:] // shallow копия слайса
s2 := s[3:5] // []int{3, 4}
s2 := s[3:]  // []int{3, 4, 5, 6, 7, 8, 9}
s2 := s[:5]  // []int{0, 1, 2, 3, 4}

```

исключительные ситуации при работе со слайсами:

```go

package main

import "fmt"

func main() {
    a := []int{1, 2, 3}
    fmt.println(a[:20]) // возникнет panic: runtime error: slice bounds out of range ошибка из за превышения capacity
    // но 
    b := make([int], 3, 300)
    fmt.println(b[:20]) // [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
    // при этом обращение к несуществующему индексу вызовет панику
    fmt.println(a[5]) // panic: runetime error: index out of range with length 3
```

пoдробнее про внутреннее устройство слайсов описано [тут](https://blog.golang.org/slices-intro)

Как реализованны слайсы:

```go
// runtime/slice.go

type slice struct {
    array unsafe.Pointer
    len int
    cap int
}
```
Неочевидные факты о слайсах:
1. При копировании слайса (а так же получении под-слайса и передаче в функцию) копируется только заголовок. Обдасть памяти остается общей, но только до тех пор пока один из слайсов не "вырастет" ( произведет реллокацию)
```go
arr := []int{1, 2}

arr2 := arr // {1, 2} идет указание на одно и то же место в памяти
arr2[0] = 42 // теперь arr и arr2  ссылаются на данные {42, 2}

arr2 = append(arr2, 3, 4, 5, 6, 7, 8)
arr2 = 1
// так как изначальное значение capacity(2) было превышено, была произведена реаллокация
// теперь  arr указывает на {42, 2}, а arr2 на { 1, 2, 3, 4, 5, 6, 7, 8}
```
 Правила работы со слайсами:
 Если необходимо написать функцию изменяющую слайс, нужно сделать так, чтобы она возвращала новый слайс. Не нужно изменять слайсы, переданные как аргументы, т.к. это shalow копии исходных слайсов.

Для получения полной копии слайса, есть функция copy

```go

s := []int{1, 2, 3}
s2 := make([]int, len(s))
copy(s2, s)
```
Сортировка слайсов происходит с помощь самописых функций. Так же существует пакет `sort`
так же есть универсальная функция для слайсов с произвольным типом данных

```go

import sort

s := []int{3, 2, 1}
sort.Ints(s) // слайс содержит простой тип данных

s := []string{"hello", "cruel", "world"}
sort.Strings(s) // строки - простой тип данных

// type User struct{
//    Name string
//    Age int
//}

s := []User{
    {"vasya", 19},
    {"petya", 20},
}
//  передан свой тип данных
// для данного случая есть func Slice(slice interface{}, less func(i, j int) bool)
// функция принимает только те данные ,которые имплементируют интерфейс slice иначе будет panic
// в качестве второго аргумента - функция которая будет сравнивать элементы, так что A < B
// https://golang.org/pkg/sort/#Slice
sort.Slice(s, func(i , j int) bool {
    return s[i].Age < s[j].Age
    })
```



#### Словари
Словать или карта(map)  - ассоциативный массив.
Нулевое значение - `nil`. Нулевая карта не содержит ключи, и ключи не могут быть добавлены.

Функция `make` умеет создавать словарь заданного типа, инициализированный и готовый к использованию

```go

package main

import (
    "fmt"
)

type Vertex struct {
    Lat, Lon float64
}

var m map[string]Vertex // создаем словарь, с типами Vertex
// var m = map[string]Vertex{"Google": Vertex{37.42202, -122.08048,}, } // словарь с ключами типа string и значениями структуры Vertex


func main() {
    m = make(map[string]Vertex) // инициализируем словарь с помощью make
    m["Bell Labs"] = Vertex{ 40.68433, -74,39967, } // заносим данные
    
    fmt.Println(m["Bell Labs"])
}
```
Изменения словарей

Добавление:
```go
m[key] = elem
```
Получение:
```go
elem = m[key]
```
Удаление:
```go
delete(m, key)
```
Проверка существования ключа:
```go

elem, ok = m[key]

// если key присутствует в m, то ok = true, если нет ok = false
// если key не присутвтует в словаре, то elem будет нулевым значением типа элементова словаря
//Примечание: если elem и ok не были объявлены, то можно использовать краткую форму записи

elem, ok := m[key]
```

#### Указатели

`uintptr`, `*int`,`*string` и т.д. подробнее в [документации](https://golang.org/ref/spec#Pointer_types)

### Безопасность

#### SQL Injection

#### XXE Processing

#### Command Injection

#### Session Fixation

#### Use of Insufficently Random Values

#### Reflected XSS
