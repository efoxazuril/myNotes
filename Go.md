sd GO

[toc]

## Начало работы с GO

### Характеристики

Императивный
Нет классов, но есть структуры и интерфейсы
Нет наследования, но есть встраивание (mixins)
Функции - объекты 1-го класса
Есть замыкания
Конкурентность
Функции могут возвращать более 1 значения
Конкурентность
Всегда собирается в 1 бинарный файл

### Структура проекта

|-go

|--bin # тут лежат скомпилированные бинарными

|--pkg # промежуточные файлы

|--src # исходные файлы

### Основные синтаксические конструкции

#### Объявление функции

```go
package main # объявление проекта

func main() {
    println("Hello, world!")
}
```

* так же это точка входа

#### Импортирование пакетов

```go
package main

import (  # импорт пакетов
    "fmt"
)

func main() {
    fmt.Println('Hello, world!')
}
```

- для многострочного сообщения используются обратные кавычки (``)

#### Объявление переменной

```go
var a int = 5 # ключевое слово var <имя переменной> <тип переменной> = <значение переменной>

c := 7 # краткий синтаксис
d,e,f := 1, 2, 3 
```

- если **не нужен** специальный тип, лучше использовать :=
- глобальные переменные объявляются только через var
- неинициализированных переменных не бывает, для записи var q int
  переменной q будет присвоено значение 0

#### Константы

```go
const(
    a int = 1
    b string = "Hello, world!"
)
```

- константы могут быть не типизированными

- `iota`  преодпределенная константа, которая устанавливает первое значение в 0, а последующие в 1, 2, 3 и т.д. обычно используется для создания `enum`

  ```go
  const (
      a = iota # 0
      b		 # 1
      c		 # 2	
  )
  ```

- _  - пустой идентификатор

#### Условный оператор if

```go
if a > b {
    //do something
} else {
    // do something else
}

if a,b := 5, 7; a > b { # присвоение внутри оператора
    // do something
}
```

- Присваивание внутри оператора обычно используется как обработки ошибок

  ```go
  if err := DoSome(); err != nil {
      //Handle error
  }
  ```

#### Цикл for

```go
for i < 10 { # замена while
    //do something
    i++
}

for { # вечный цикл
    // do something 
    i++
    if (i > 10) {
        break # еще есть continue
    }
}

a := [...]int{81, 54, 43, 66}
for index, value := range a {
    //do something
}
```

- других циклов нет

#### Конструкция switch

```go
switch a {
    case 10:
    	//do something
    default:
    	//do default
}
switch a {
    case 10:
    	//do something
    	fallthrought # проваливание
    case 20:
    	//do something
    	fallthrought
    default:
    	//do default
}
```

- `break ` - писать не нужно
- `fallthrought` - позволяет перейти к следующему `case`

### Инструментарий

#### Инфраструктура языка

##### Единое дерево кода

###### GOROOT и GOPATH

**`GOPATH`** - переменная, которая сообщает, где содержатся исходники

**`GOROOT`** - путь где лежат исходники самого языка

Плюсы:

- Простота. Плоская структура.
- Отсутствие версий

Минусы:

- Отсутствие версий
- Иногда в проекте не только Go-код

##### Модули (Go Modules)

Начиная c Go 1.11 появилась поддержка модулей
Модуль любая директория содержащая файл go.mod (любая директория вне GOPATH)

**`go.mod`** - файл, по которому go понимает что данная директория - модуль.

```bash
go mod init <путь репозитория> #инициализирует модуль, создаст файл go.mod
```

Внутри модуля команды `go get` скачивает и фиксирует версии пакетов.
Внутри файла `go.mod` - содержатся информации о зависимостях модуля.
Внутри модуля будет файл `go.sum`, который содержит чек-суммы зависимостей.

###### Как управлять зависимостями при разработке

В импорте пакета:

```go
package main

import (
    "fmt"
    "github.com/go/loremipsum"
)
```

Затем запустить:

```bash
go mod tidy #смотрит на импорты и обновляет зависимости
```



##### go get

Скачивает пакет

- `https://` - писать не нужно. Например: `github.com/golang/protobuf`

`go get` - скачает и установит
`go get -d`- скачать но не устанавливать. Обычно не используется.
Многоточие `...` например `github.com/golang/protobuf/...`, означает что нужно скачать все зависимости пакета.

- вообще `...` это сделать что-то рекурсивно

`go get -u` обновит пакет

##### go build

Собирает точечно собирает пакет. В большинстве случаев следует использовать `go install`. Но `go build` всегда пересобирает пакет.

##### go install

Компилирует указанный пакет и устанавливает его. Переносит в `$GOPATH/pkg`
Исполняемый файл будет помещен в `$GOPATH/bin`
Сохраняет все промежуточные пакеты.

#### Кросс-компиляция

Go может скомпилировать файл для разных ОС и архитектур. Для этого при сборке нужно переопределить переменные `GOOS` и `GOARCH`

```bash
GOARCH=386 GOOS=darwin go build -o /tmp/protobuff github.com/golang/protobuf/...
```

Возможные значения можно посмотреть [Значения GOOS и GOARCH ](https://gist.github.com/asukakenji/f15ba7e588ac42795f421b48b8aede63)

#### Одиночный запуск

```bash
go run <path/to/file.go> #запустит файл, можно проверить синтаксис и работу кода
```

#### Форматирование кода (gofmt)

```bash
go fmt <path/to/file> # форматирует файл согласно стандарту
```

#### Форматирование импортов (внешняя надстройка над gofmt) goimports

[Устанока и документация](https://godoc.org/golang.org/x/tools/cmd/goimports)

Следит за импортами добавляет / удаляет нужные.

#### Линтеры

##### go vet

Встроенный линтер

##### golint

Сторонний линтер https://github.com/golang/lint

##### Мета-линтер golangci-lint

Агрегатор линтеров - https://golangci-lint.run управляет сторонними лихтерами, может запускать цепочки линтеров.

#### Тестирование

Файлы с тестами должны быть названы специальным синтаксисом <пакет>_test.go
В данном файле содержатся тесты для пакета. Данные файлы участвуют только в тестировании.

##### Unit-тесты

Следует писать unit-тесты для функциональности, т.е. тестируется отдельная функциональность, а не полная инфраструктура

Пример:

```go
# основной пакет foobar
package foobar

func Count(s string, r rune) int {
    var cnt int
    for _, l %= range s {
        if l == r {
            cnt += 1
        }
    }
    
    return cnt
}


# foobar/count_test.go

package foobar #тесты пакета в том же пакете

import "testing"

#тестом является любая функция со слова Test
#такая функция должна принимать аргумент t * testing.T
func TestCount (t *testing.T) { 
    s := "qweqwe"				
    e := 2
    if c := Count(s, 'e'); c != e {
        t.Fatalf("bad count for %s: got %d expected %d", s, c, e) # будет вызвано при непрохождении теста
    }
}
```

 Запуск тестов:

```bash
go test # тесты в текущей директории
go test github.com/gorilla/mux # тесты произвольного пакета
go test google.golang.org/grpc/... # тесты включая вложенные пакеты
```

##### Пакет testing

t.Fail() // отметить тест как сломанный, но продолжить выполнение

t.FailNow() // отметить тест как сломаный и прекратить текущий тест

t.Logf(formar string, ...interface{}) // вывести сообщение с отладкой

**t.Errorf(formar string, ...interface{})** // t.Log + t.Fail

**t.Fatalf(formar string, ...interface{})** // t.Log + t.FailNow

t.SkipNow() // пропустить тест

##### Пакет [testify](https://github.com/stretchr/testify)

Пакет содержит дополнительные инструменты для тестирования, расширяющие стандартный **testing**

##### Best practices тестирования

- Тесты должны быть достоверными и исерпывающими
  Тесты должны ломаться, только тогда, когда действительно не работает код
- Тесты - это тоже код
- Один тест - один тестовый случай
  На 1 библиотечную функцию 1 тест, но иногда имеет смысл разбить тест на отдельные сценарии
- Тесты должны быть изолированы
  Следует избегать веерных поломок тестов
- Тесты должны обрабатывать быстро
- Тесты не должны использовать результаты другого теста
- Не следует выводить diff для сравнения глазами
- Избегать слишком большого количества проверок в 1 тесте
- Не следует иметь зависимости от внешних файлов (вне репозитория)
- Следует избегать неполного тестирования (если покрывать тестами - то все)

### Элементарные типы данных

#### Объявление переменных в Go

```go
var Storage map[string]string // zero value

# Все что начинается с большой буквы - экспортируемое (видно в других пакетах)
# маленькая буква - private

var storage = make(map[string]string) // автовывод типа
#в полном варианте должно было быть var storage map[string]string = make(map[string]string)

var some = 3 // автовывод типа

# func <название>() <возвращаемый тип>
func Answer() int {
    return 42
}

func main() {
    # локальные переменные
    var i int = 10
    j := i // короткое объявление, только внутри функций, глобальные функции так указывать нельзя
}
```

##### Публичные и приватные идентификаторы

Публичные идентификаторы - те, которые видны за пределами пакета. Публичные идентификаторы начинаются с заглавной буквы

Приватные идентификаторы - начинаются со строчной буквы и видны только внутри пакета.

Структуры могут содержать как приватные так и публичные поля.

```go
type User struct {
    Name	 string
    password string
}
```

#### Целые типы

`int`, `uint`, `uint8` и т.д. подробнее в [документации](https://golang.org/ref/spec#Numeric_types)

К некоторым типам есть алиасы:

`byte` = `uint8`
`rune` = `int32`

Всегда есть значение "по умолчанию" = 0
Типы int и uint могут принимать значения 32 и 64 бита на разных платформах.
**Нет автоматического преобразования типов.**

#### С плавающей точкой

`float32`
`float64`

#### Комплексные числа

`complex64`, `complex128`

#### Строки (неизменяемая последовательность байт!)

[Документация](https://blog.golang.org/strings)

```go
# внутренняя структура строки
type stringStruct struct {
    str unsafe.Poinet
    len int
}
```

`byte = uint8`

`string`



##### Строковые литералы

```go
s := "hello, world!" # в двойных кавычках, на одной строке
s := 'hello \n world \u9333' # в одинарных кавычках с непечатными символами

// если нужно включить в строку кавычки или переносы строк
s := `hello
"cruel"
'world'
`
```

##### Действия со строками

```go
s := "hello world" // создает строку
var c byte = s[0] // получить доступ к байту(!) в строке
var s2 string = s[5:10] // получить подстроку в байтах(!)
var := s + "again" // конкатенация - очень дорогая операция в Go
l := len(s) // узнать количество байт в строке


```

**Устройство  Unicode в  GO**

Исходники Go  и все литералы - в кодировке  UTF-8

Как устроен UTF-8

UTF-8 - многобайтовая

(Подробнее в устройстве [UTF-8](https://habr.com/ru/post/113715/))

`Z`= `5A`

`Я` = `DO AF`



#### Указатели

`uintptr`, `*int`,`*string` и т.д. подробнее в [документации](https://golang.org/ref/spec#Pointer_types)

### Безопасность

#### SQL Injection

#### XXE Processing

#### Command Injection

#### Session Fixation

#### Use of Insufficently Random Values

#### Reflected XSS



