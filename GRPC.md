# GRPC (google Remote Procedure Call)
## Overview
В GRPC клиентское приложение может напрямую вызывать какой-либо метод в серверном приложении так, как будто это локальный объект, упрощая тем самым создание распределенных приложений и сервисов. GRPC базируется на идеи определения какого-либо сервиса, специфицируя методы которые могут быть вызваны удаленно с их параметрами и возвращаемыми типами. На серверной стороне, такой сервер реализует этот интерфейс и запускает GRPC сервер для обработки клиентских вызовов. На клиентской стороне, клиент имеет упрощенные методы сервера.

## Работа с Protocol Buffers
По-умолчанию, GRPC использует *Protocol Buffers*, это механизм сериализации структурированных данных.

1. при работе с Protocol Buffers необходимо определить структуру ваших данных ( которые вы хотите серелиазовать ) в _proto_ файл: это обычный текстовый файл с расширением *_.proto_*. Protocol buffer данные структурируются как _сообщения_, где каждое сообщение это маленькая логическая запись в формате имя-значение.

```proto

message Person {
    string name = 1;
    int32 id  = 2;
    bool has_ponycopter = 3;
}
```
После того как сообщения сформированы, необходимо запустить компилятор *_protoc_* для генерации класса на предпочитаемом языке программирования (по сути на том, который будет использован, для сервера / клиента)

## Core concepts, architecture and lifecycle
### Service definition
gRPC позволяет определить 4 разных типа методов:
- Unary RPC (унарный вызов удаленной процедуры) - клиент посылает один запрос на сервер и получает один ответ
    
```proto
    rpc SayHello(HelloRequest) returns (HelloResponse);
```
-- Life cycle

1. Клиент вызывает метод у `stub`, сервер уведомлен что RPC был вызван с клиентскими метаданными для этого вызова, имя метода и `deadline` если таковой указан.
2. Сервер можен либо отправить назад метаданные ( которые отправляются до ответа) прямо назад, либо дождаться клиентского сообщения. Порядок определяется спецификой приложения.
3. Когда сервер получил клиентское сообщение, выполняется необходимая работа для того, чтобы создать и отправать ответ. Как только будет возврат ответа ( в случае успеха) клиенту вместе со статусом ( статус код + опциональный статус сообщения) и опциональные последующие метаданные.
4. Если статус ответа - ОК - когда клиент получает ответ, это заканчивает вызов на стороне сервера.

- Server Stream RPC - клиент отсылает запрос к серверу и получает поток (`stream`) чтобы прочитать последовательность возвращенных сообщений. Клиент читает из потока до тех пор, пока не закончатся сообщения. gRPC гарантирует последовательность сообщений внутри индивидуального RPC запроса.

```proto
    rpc LotsOfReplies(HelloRequest) returns ( stream HelloResponse);
```

-- Life cycle

Отличия от unaryCall в том, что сервер возвращает поток сообщений в ответе клиенту. После отправки всех сообщений, серверные данные (статус + отциональное статусное сообщение + последующие данные) отправляются клиенту. Клиент заканчивает работу как только получить все сообщения от сервера.

- Client Stream RPC - когда клиент пишет последовательность сообщений и отправляет их на сервер, через предоставленный поток. Как только клиент заканчиваетписать сообщения, он ждет пока сервер прочитает и ответит. Опять же gRPC гарантирует порядок сообщений внутри индивидуального RPC вызова.

```proto
    rpc LotsOfGreetings( stream HelloRequests) returns (HelloResponse);
```

-- Life cycle

В отличии от unaryCall в том, что клиент отправляет поток сообщений серверу, вместо одиночного сообщения. Сервер отвечает одиночным сообщением(вместе со статусом и опциональными последующими метаданными) обычно ( но не обязательно) после приема всех сообщений от клиента.

- Двунаправленный потоковый режим (Bidirectional streaming RPC) когда обе стороны посылают последовательность сообщений используя read-write stream. Оба потока работают независимо, так клиент и сервер могут читать и писать в том порядке, и котором работают: для примера, сервер может ждать приема сообщений от всех клиентов перед записью ответов им. Порядок сообщений в каждом потоке сохраняется.

```proto
    rpc BidiHello(stream HelloRequest) returns (stream HelloResponse);
```

-- Life cycle

В двунаправленном режиме, вызов инициализируется клиентом, путем (invoking) вызова метода а сервером приема клиентсих метаданны, имени метода и `deadline`. Сервер может выбрать одно из действий: отправкой инициализирующих метаданных или ожидает открытия `stream` от клиента.

Потоки со стороны клиента и сервера работают по спецификации клиента. С этих пор оба потока независимы, и клиент и сервер могут и читать, и писать сообщения в любом порядке. Для примера сервер может ожидать пока не получит все клиентские сообщения, до того как станет писать свои сообщения, или сервер и клиент могут играть в "пинг-понг" - отправляет назад ответ, после клиент отправляет другой запрос основанный на ответе и т.д.

### Использование API

gRPC предлагает плагин, который генерирует код для клиента и сервиса.

- На серверной стороне, данный сервер реализует методы объявленные сервисом и запускают gRPC сервер для обработки клиентский вызовов. Инфраструктура gRPC декодирует входящие запросы, исполняет сервисные методы и кодирует сервисные ответы.

- На стороне клиента, клиент имеет логический объект известный как `stub` ( для некоторых языков, предпочтительный термин `client`) который реализует такие же методы как и у сервиса. Клиент можен вызывать эти методы на логическом объекте, оборачивая параметры для вызова соответствующего сообщения типа protocol buffer - gRPC следит за отправкой запросов на сервер и возвращением серверного ответа типа protocol buffer.

### Deadlines / Timeouts
gRPC позволяет клиенту сообщить скольео он хочет ждать RPC для завершения, перед тем как RPC ответит `DEADLINE_EXCEEDED` ошибкой. На серверной стороне, сервер может принять решение что время вышло или как много времени прошло , чтобы завершить RPC.

Определение `deadline` или `timeout` зависит от языка: некоторые языковые API работают в терминах `timeout` (те продолжительность времени) а некоторые в терминах `deadline` (те фиксированная точка времени) либо могут или не могут иметь значения по-умолчанию.

### Прекращение RPC
В gRPC обе стороны (клиентская и серверная) делают независимые и локальные определения положительного ответа, и их заключения о несовпадении. Это значит что, для примера, вы можете иметь RPC который заканчивает свои процедуры успешно на серверной стороне, но возвратит неудачу на клиентской части ( допустим сообщение пришло уже после `deadline`). Так же возможно дать серверу полномочия завершить исполнение перед тем как клиент отправит все запросы.

### Отмена RPC
Обе стороны могут отменить RPC в любое время. Отмена принудительно и мгновенно заканчивает RPC без выполнения работы.
!!!Предупреждение
Изменения сделанные перед отменой не будут отменены. ( are not roll back)

### Metadata (Метаданные)
Метаданные - информация о частном RPC вызове ( например аутентификационные данные) в форме пары ключ-значение, где ключи это строки и значения обысно строку, но могут быть и бинарные данные. Метаданные непрозрачны для самого gRPC - они позволяют клиенту предоставлять информацию, связанную с вызовом на сервер и наоборот.

Доступ к метаданным язвкозависимы.

### Channels (Каналы)
gRPC канал предоставляет соединение к gRPC серверу по определенному адресу и порту. Установка происходит при создании клиентского `stub`. Клиенты могут определить аргументы канала, чтобы модифицировать стандартное поведение gRPC, например включение/выключение сжатия сообщений. Канал имеет состояние включая `connected` и ` idle`.

Как gRPC будет закрывать канал зависит от языка реализации. Некоторые языки также позволяют запрашивать состояние канала.

## Аутентификация (https://grpc.io/docs/guides/auth)
## Benchmarking (https://grpc.io/docs/guides/benchmarking)
## Обработка ошибок (https://grpc.io/docs/guides/error)

# Описание Protobuff
