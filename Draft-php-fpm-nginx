Виктор Кузьмин, [15 Apr 2020, 19:53:31 (15.04.2020, 20:07:04)]:
Пара определений чтобы дойти до PHP-FPM.

SAPI - Server Application Programming Interface
Программа реализующая определенный интерфейс взаимодействия с интерпретатором ЯП (в нашем случае PHP).
Например php-cli это SAPI которое позволяет тыкать пыху через консоль.

SAPI которые нас сейчас интересуют:

1. CGI
2. FastCGI
3. PHP-FPM

Они все позволяют общаться с пыхой через веб-сервер.

1. CGI - Common Gateway Interface.
Стандарт описывающий взаимодействие веб-сервера и прикладной программы. 
Как запускать скрипт. В каком виде передавать параметры HTTP-запроса. В каком формате отдавать ответ.

Принцип работы:
1. Клиент кидает запрос.
2. Сервер его принимает.
3. Устанавливает переменные окружения через которые передается служебная информация.
Например REMOTE_ADDR - IP-адрес клиента.
4. Перенаправлет запрос через стандартный поток ввода (stdin) на вход скрипта.
5. Скрипт выпоняет расчеты и формирует ответ в формате HTTP.
6. Ответ возвращается серверу через stdout. Ошибки через stderr.
7. Сервер возвращает результаты клиенту.

Реализация CGI в PHP.

Самый старый и самый простой способ выполнения php-скриптов веб-cервером.
Доступен по-умолчанию, но при компиляции можно отключить. 
Производительность - нихуя. Потому почти не используется.

С Apache можно подружить через mod_cgi (модуль Apache).
С Nginx не дружит, но вроде есть какие-то плагины(костыли) для решения этой проблемы.

2. FastCGI

Дальнейшее развитие технологии CGI. Более производительный и безопасный.

Принцип работы:

1. Программа загружается в память в качестве демона.
2. Входит в бесконечный цикл обработки.
3. В зависимости от настроек поднимет необходимое количество воркеров.
4. Воркеры начинают обрабатывать запросы от веб-сервера.
5. После её окончания берут следующий запрос из очереди.

В чем преимущество перед CGI:

1. Не тратятся ресурсы на постоянное поднятие новых процессов и внутреннего окружения требуемого скриптом - либы, зависимости и.т.п.
2. Для взаимодействия с веб-вервером используются не потоки ввода/вывода, а сокеты. Это позволяет запустить FastCGI-скрипт как на удаленной машине, так и разделить нагрзку на несколько скриптов.

Реализация FastCGI в PHP

У PHP времен 5.3 - 5.5 была своя реализация FastCGI.
Но проблемы с производительностью, утечки памяти, поэтому после релиза php-fpm её выпилили.

Важная особенность реализации FastCGI в PHP - в памяти висит сам интерпретатор, а не какой-то конкретный скрипт.
Т.е. все либы и зависимости каждый раз подгружаются заново*. Модель умирания, все дела.
Частично компенсируется OPCache и Preload.

Для работы с Apache нужен модуль mod_fastcgi. 
Nginx умеет работать в режиме FastCGI, но конкретно с PHP дружит только через php-fpm.

Виктор Кузьмин, [15 Apr 2020, 20:19:54 (15.04.2020, 20:20:56)]:
3. FPM - FastCGI Process Manager

Альтернативная реализация протокола FastCGI для PHP от компании Badoo, с рядом улучшений заточеных под высоконагруженные сайты:

1. Продвинутое управление процессами с корректной процедурой остановки.
2. Запуск воркеров с разным окржением uid/guid/chroot и php.ini
3. Логирование stdout и stderr.
4. Аварийный перезапуск в случае внезапного разрушения opcode-кеша.
5. Поддержка ускоренной загрузки.
6. Slowlog для медленно выполняющихся скриптов.
7. Базовая информация о статусе SAPI.

Для работы с Apache нужен модуль mod_proxy_fcgi. 
Однако по большей части используется в связке с Nginx т.к. Apache в странах СНГ уже не торт.

Ну и бонусом, кратко про Apache и Nginx.

Apache

Опенсорсный кросплатформенный веб-сервер. Зарелизился в 1995 году. 
Приобрел большую популянрость. Построен на основе процессно-ориентированного алгоритма. 

Принцип работы: 

Под каждый запрос поднимается отдельный процесс(тред) и необходимое для обработки окружение. Основная проблема такого подхода кроется в том, что для Apache нет разницы за чем и как пришли.
Статика, динамика, keep-alive соединение. Для всего будет поднят новый процесс(тред). Что отжирает дохера памяти и проца.

Есть несколько вариантов реализации обработки запросов т.н. MPM (multi processing module):

1. Prefork - задается максимальное кол-во одновременно поднимаемых заранее процессов. Которые ждут соединений для обработки. Следовательно если все занято, излишек идет нафиг.
2. Worker - примерно та же идея, только процессы запускают потоки, которые уже обрабатывают соединения. Это быстрее и легче по оперативе, но менее надежно.
3. Event - дальнейшее развитие worker в котором потоки не умирают, а прдолжают обрабатывать новые соединения.

Плюсы:

1. Глобальный конфиг - apache2.conf. Можно отдельно расширить под каждую папку сервера - htaccess.
2. Кроссплатформенный.
3. Динамически подключамые модули.

Nginx

Простой, быстрый и легкий http-proxy-сервер разработанный в 2004 году Игорем Сысоевым.
Построен на основе событийно-ориентированнго алгоритма с неблокируемой асинхронной обраоткой запросов. 

Принцип работы:

Поднимается один рабочий процесс nginx (мастер). Который в бесконечном event-loop'е разбирает worker'ами запросы от клиентов. Пришла динамика, перекинули (проксирование) её на бекенд (fpm), пока бекенд занят обработкой, worker освободился, взял новый запрос. Пришла статика, сообщил диску о том, что надо поставить в очередь чтение файла. FPM сообщил о готовности запроса, отдали ответ клиенту. И.т.д.

Плюсы:

1. Легче, жрет меньше оперативы и проца.
2. Изначально заточен под обработку статики.
По бенчмаркам отдает её быстрее Apache в 2-3 раза. Выдерживает гораздо больший RPS.
3. Быстрее разбирает запросы т.к. не нужно учитывать +100500 htaccess'ов.

Доп. фишки Nginx как прокси-сервера.

1. Балансировка – nginx может выполнять балансировку нагрузки для распределения клиентских запросов по серверам, что повышает производительность, масштабируемость и надежность. 

2. Кэширование – nginx может кэшировать контент, полученный от серверов, и использовать его для ответа клиентам, не обращаясь к серверу для получения одного и того же контента несколько раз.

3. Завершение SSL – nginx может выступать в качестве конечной точки SSL для соединений с клиентами. Он будет обрабатывать и дешифровать входящие соединения SSL и шифровать ответы сервера.

4. Сжатие – если сервер не отправляет сжатые ответы, можно настроить nginx для сжатия ответов перед их отправкой клиентам.

Клиент стучится на 80 порт. Или 443(https).
Nginx слушает эти порты и берет запрос в обработку. Дергает воркер. 
Воркер парсит url, смотрит конфиг - все запросы к такому-то хосту нужно кидать в index.php.
Дерагет PHP-FPM, идет делать что-нибудь еще полезное.
PHP-FPM создает воркер, тот дергает index.php и создает нужные переменные окружения.
А уже index.php когда парсит url(педположим что у нас роутинг и MVC) понимает в какой контроллер передать твой запрос.
