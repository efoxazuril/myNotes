# MYSQL

## Содержание

[CAP - теорема](#CAP-теорема)

[Документация](#Документация)

[Подключение к БД](#Подключение-к-БД)

[КОНФИГУРАЦИОННЫЙ ФАЙЛ .my.cnf](#КОНФИГУРАЦИОННЫЙ-ФАЙЛ-.my.cnf)

[Отключение от БД](#Отключение-от-БД)

[ТИПЫ ДАННЫХ](#ТИПЫ-ДАННЫХ)

> [Атрибуты](#Атрибуты)

[Базовые операции](#Базовые-операции)

>[SHOW](#SHOW)
>
>[USE](#USE)
>
>[CREATE](#CREATE)
>
>[DESCRIBE](#DESCRIBE)
>
>[INSERT](#INSERT)

>[SELECT](#SELECT)
>
>[DELETE](#DELETE)
>
>[ALTER TABLE](#ALTER-TABLE)
>
>[TRUNCATE](#TRUNCATE)

[ДОБАВЛЕНИЕ, УПРАВЛЕНИЕ И УДАЛЕНИЕ ПОЛЬЗОВАТЕЛЕЙ](#ДОБАВЛЕНИЕ,-УПРАВЛЕНИЕ-И-УДАЛЕНИЕ-ПОЛЬЗОВАТЕЛЕЙ)

> [Создание пользователя](#Создание-пользователя)

[DDL, DML](#DDL,-DML)

[КЛЮЧЕВЫЕ СЛОВА](#КЛЮЧЕВЫЕ-СЛОВА)

> [SERIAL](#SERIAL)

[СОЗДАНИЕ ДАМПА](#СОЗДАНИЕ-ДАМПА)

[ДВИЖКИ ТАБЛИЦ MYSQL](#ДВИЖКИ-ТАБЛИЦ-MYSQL)

> [MyIsam](#MyIsam)
>
> [InnoDB](#InnoDB)

[ИНДЕКСЫ И КЛЮЧИ](#ИНДЕКСЫ-И-КЛЮЧИ)

>[Как происходит чтение данных с диска.](#Как-происходит-чтение-данных-с-диска.)
>
>[Поиск данных в MySQL](#Поиск-данных-в-MySQL)
>
>[Сортировка данных](#Сортировка-данных)
>
>[Виды индексов](#Виды-индексов)
>
>>[Обычный индекс](#Обычный-индекс)
>>[Уникальный индекс](#Уникальный-индекс)
>>[Первичный ключ](#Первичный-ключ)
>>[Составной индекс](#Составной-индекс)
>>[Кластерный индекс](#Кластерный-индекс)
>>[Покрывающий индекс](#Покрывающи-индекс)
>>[Полнотекстовый индекс](#Полнотекстовый-индекс)

[СЛОЖНЫЕ ЗАПРОСЫ](#СЛОЖНЫЕ-ЗАПРОСЫ)
> [UNION](#UNION)
> [ВЛОЖЕННЫЕ ЗАПРОСЫ](#ВЛОЖЕННЫЕ-ЗАПРОСЫ) 

[РЕПЛИКАЦИЯ](#РЕПЛИКАЦИЯ)

[ШАРДИНГ](#ШАРДИНГ)

> [Вертикальный шардинг](#Вертикальный-шардинг)
>
> [Горизонтальный шардинг](#Горизонтальный-шардинг)

[СИСТЕМНЫЕ БД](#СИСТЕМНЫЕ-БД)

> [mysql](#mysql)
>
> [information_schema](#information_schema)

[СПИСОК ИСПОЛЬЗОВАННЫХ МАТЕРИАЛОВ](#СПИСОК-ИСПОЛЬЗОВАННЫХ-МАТЕРИАЛОВ)

### CAP-теорема
```bash
С - consistensy - все клиенты могут прочить одни и те же данные , на один и тот же запрос, даже при обновлении данных
A - availibility - доступность - все клиенты имеют возможность читать / писать данные, не нужно ждать завершения операций
P - partition tolerance - устойчивость к разделению - БД можно разделить между несколькими машинами и она продолжит работать в случае отказа одного элемента сети
	
CAP - теорема говорит о том, что система может быть либо CA либо AP либо CP
	
CA {MySQL, PostgreSQL}
AP {Cassandra, Riak}
CP {Redis, MongoDB}
```

Существуют инструменты, для обеспечения недостающих частей.
Обычно используют 2 БД каждая из которых закрывает одну из граней треугольника CAP -теоремы

### Документация

[Официальная документация на сайте](https://dev.mysql.com/doc/)

### Подключение к БД

```shell
mysql -h 127.0.0.1 -P 3306 -u <user> -p
	  -u  # пользователь
	  -p  # для входа будет использован пароль
	  -P  # порт соединения
	  -h  # хост соединения 
```

При первом подключении нужно сбросить пароль от `root` .

```mysql
ALTER USER 'root'@'localhost' IDENTIFIED BY '<new_password>'
```

### КОНФИГУРАЦИОННЫЙ ФАЙЛ .my.cnf

[Официальная документация](https://dev.mysql.com/doc/refman/8.0/en/option-files.html)

Обычно для подключения нужно вручную писать имя пользователя, пароль, хост и т.д. Но можно использовать специальный конфигурационый файл, где кроме параметров подключения, можно перечислить другие настройки.

Файл должен быть помещен в домашней директории пользователя, для авторизации без ввода пароля можно прописать следующие параметры

```bash
[MYSQL] # секция
user=root # параметры в формате param=value
password=password
```

Не забываем, что данный файл должен быть прочитан только данным пользователем

```bash
chmod 0600 ~/.my.cnf
```



### ОТКЛЮЧЕНИЕ ОТ БД

```mysql
QUIT
```

### ТИПЫ ДАННЫХ

1. числовые

   Чем ниже в этом списке тип, тем дольше с ним будет работать сервер

   1.1 Целочисленные

   `TINYINT` -  1 байт

   `SMALLINT` - 2 байта

   `MEDIUMINT` - 3 байта

   `INT` - 4 байта

   `BIGINT` - 8 байт

   1.2 Вещественные

   `FLOAT` - 4 байта

   `DOUBLE ` - 8 байт

   1.3 Точные - DECIMAL

   `DECIMAL` - в данном типе под хранение отводится 7 байт

   число хранится в виде строки, но не теряет точность.

2. строковые

   Строковые типы имеют ограничения, записи в таблице представлены в виде структуры фиксированного размера. Это позволяет быстро переходить к нужной записи, так как размер известен заранее и мы можем перемещать указатель на нужный адрес. Под столбцы переменной длины отводится специальная область длинной 65 536 байт. Таким образом, нельзя в таблице создать столбцы **VARCHAR**, совокупный размер которых больше, чем эта специальная область.Так как для кодирования строк используется UTF-8, ситуация еще более печальная: для символов, отличных от английских, зачастую используется больше одного байта, например русский текст кодируется двумя байтами.

   **В MySQL нет полноценной поддержки UTF-8, поэтому под все символы этой кодировки отводится либо 3 либо 4 байта. Таким образом, в VARCHAR-значениях можно уместить лишь очень короткие строки**

   2.2 фиксированные строки

   Фиксированные строки, которые задаются типом **CHAR**, если при создании таблицы отводится 40 символов — именно столько памяти и займет запись;

   2.3 переменные строки

   переменные строки, которые задаются типом **VARCHAR**, не имеют фиксированного размера, занимаемый объем определяется размером строки; впрочем, допускается задание максимального объема строки в круглых скобках после запятой;

   Для хранения объемного текста используется тип `TEXT` со своими подтипами

   `TINYTEXT` - 2^8 байт

   `TEXT` - 2^16 байт

   `MEDIUMTEXT` - 2^24  байта

    `LONGTEXT` - 2^32 байт

   2.4 `BLOB - типы`

   `BLOB-типы`, которые изначально задумывались для хранения объемных бинарных данных, однако в результате были адаптированы для хранения текстовых значений.

3. специальный тип NULL

   Все операции с `NULL` вернут `NULL`

   Чтобы запретить значения с `NULL` необходимо добавить

4. календарные

   `YEAR` - '0000'

   `DATE` - '0000-00-00'

   `TIME` - '00:00:00'

   `DATETIME` - '0000-00-00 00:00:00'

   `TIMESTAMP` - от 1970 до 2038 

5. коллекции

   5.1 `ENUM`

   Список значений, задается списком строк.

   ENUM поле сможет принять 1 значение из списка

   5.2 `SET`

   Список значений, задается списком строк.

   SET хранит комбинацию из заданных значений.

   5.3 `JSON`

   Способен хранить готовый `JSON` объект. При помощи спец. синтаксиса можно обращатся к полям такого объекта.

#### Атрибуты

Многие типы могут сопровождаться дополнительнымы атрибутами

`NULL`  и  `NOT NULL` - ограничение на столбец, задает поведение при отсутствующем значении.
`DEFAULT` - позволяет задать полю значение по умолчанию
`UNSIGNED` - поле будет хранить беззнаковое число.
`AUTO_INKREMENT` - 

### БАЗОВЫЕ ОПЕРАЦИИ

##### SHOW

```mysql
SHOW DATABASES; ## Показывает существующие базы дынных
SHOW TABLES; ## Показывает таблицы в выбранной БД
SHOW CREATE TABLE <name>; ## Показывает запрос на создание даной таблицы
SHOW ENGINES; ## Вывести список доступных движков
SHOW VARIABLES LIKE 'datadir'; ## покажет где физически расположены файлы с данными
```
##### USE

```mysql
USE <name>; ## Переключается на указанную БД
```
##### CREATE

```mysql
CREATE DATABASE <name>; ## Создает БД с указанным именем

CREATE TABLE <name> (
	id SERIAL PRIMARY KEY,
    name VARCHAR(150) NOT NULL,
    owner VARCHAR(150) NOT NULL,
    PRIMARY KEY	(id)
) ## Создает таблицу в указанной БД с необходимыми полями
```
##### DESCRIBE

только для  MySQL

```mysql
DESCRIBE <name>; ## Показывает информацию о колонках в таблице
DESCRIBE <name> 'column_name' ## Показать информацию о столбце
DESCRIBE <name> 'n%' ## Аналогично оператору LIKE % - последующие символы, _ - 1 символ
```
##### INSERT

```mysql
INSERT INTO <name> (name, ower) VALUES ('Sandy', 'John'); ## Производит вставку значения в таблицу
```
##### SELECT

```mysql
SELECT * FROM <name>; ## Делает выборку всех записей из указанной таблицы
```
```mysql
SELECT * FROM <name> WHERE name = 'Sandy'; ## Делает выборку по условию
```
##### DELETE

```mysql
DELETE FROM <name> WHERE name = 'Sandy'; ## Удаляет запись из ьтаблицы по условию
```
##### ALTER TABLE

```mysql
ALTER TABLE <name> ADD gender CHAR(1) AFTER name; ## Изменяет таблицу
```
```mysql
ALTER TABLE <name> DROP gender;## Удаляет колонку из таблицы
```
#### TRUNCATE

```sql
TRUNCATE <table_name>; # очищает таблицу
```

### Транзакции

Транзакция представляет собой группу запросов SQL, обрабатываемых атомарно,
то есть как единое целое. Если подсистема базы данных может выполнить всю группу
запросов, она делает это, но если какой-либо запрос не может быть выполнен
в результате сбоя или по иной причине, ни один запрос группы не будет выполнен.

Начало транзакции

```sql
START TRANSACTION;
```

Далее идут запросы к БД, которые должды быть выполнены в ходе транзакции

Фиксация изменений происходит коммандой

```sql
COMMIT;
```

В случае ошибки, необходимо произвести откат

```sql
ROLLBACK;
```

Транзакции стараются следовать принципам ACID

#### ACID

**A** - atomicy - атомарность - Транзакция должна функционировать как единая неделимая рабочая единица таким образом, чтобы вся она была либо выполнена, либо отменена.
Для атомарных транзакций не существует такого понятия, как частичное выполнение:
все или ничего.
**С** - consistensy - согласованность -  База данных всегда должна переходить из одного согласованного состояния в другое. Это значит, что в случае сбоя, данные не будут повреждены, ни одно из изменений не отразится на БД.
**I** - isolation - изолированность - параллельные транзакции изолированный друг от друга. Результаты транзакции обычно невидимы другим транзакциям, пока она не подтверждена.
**D** - durability - сохраняемость - обязательноство не терять данные при сбое

##### Уровни изолированности

Стандарт SQL определяет 4 уровня со своими правилами, которые устанавливают видимость изменений в ходе транзакции.

**READ UNCOMMIТТED.** 
На этом уровне изолированности транзакции могут видеть
результаты незавершенных транзакций. Вы можете столкнуться с множеством проблем, если не знаете абсолютно точно, что делаете. Используйте этот уровень, только если у вас есть на то веские причины. На практике этот уровень применяется редко, поскольку в этом случае производительность лишь немного выше, чем на других уровнях, имеющих множество преимуществ. Чтение незавершенных данных называют еще черновым, или ~грязным» чтением (dirty read).

**READ COMMIТТED.**
Это уровень изолированности, который устанавливается по умолчанию в большинстве СУБД **(но не в MySQL!).**  Он соответствует приведенному ранее простому определению изолированности: транзакция увидит только те изменения, которые к моменту ее начала подтверждены другими транзакциями, а произведенные ею изменения останутся невидимыми для других транзакций, пока текущая не будет подтверждена. На этом уровне возможно так называемое неповторяющееся чтение (nonrepeataЫe read). Это означает, что вы можете выполнить одну и ту же команду дважды и получить разный результат.

**REPEATABLE READ.**
Этот уровень изолированности позволяет решить проблемы, которые
возникают на уровне **READ UNCOMMIТТED.** Он гарантирует, что любые строки,
которые считываются транзакцией, будут выглядеть одинаково при последовательных
операциях чтения в пределах одной транзакции, однако теоретически
на этом уровне возможна другая проблема, которая называется фантомным
чтением **(phantom reads)**. Проще говоря, фантомное чтение может произойти
в случае, если вы выбираете некоторый диапазон строк, затем другая транзакция
вставляет в него новую строку, после чего вы снова выбираете тот же диапазон.
В результате вы увидите новую, фантомную строку. **InnoDB** и **XtraDB** решают
проблему фантомного чтения с помощью многоверсионного управления конкурентным
доступом (multiversion concurrency control).Уровень изолированности **REPEATABLE READ** устанавливается в MySQL по умолчанию.

**SERIALIZABLE.** 
Самый высокий уровень изолированности, который решает проблему фантомного чтения, заставляя транзакции выполняться в таком порядке, чтобы исключить возможность конфликта. Если коротко, уровень **SERIALIZABLE** блокирует каждую читаемую строку. На этом уровне может возникать множество задержек и конфликтов блокировок.

| Уровень изоляции | Возможность чернового чтения | Возможность неповторяющегося чтения | Возможность фантомного чтения | Блокировка чтения |
|--------------------|-----------------------|-------------------|-------------------|
| READ UNCOMMIТТED | Да | Да | Да | Нет|
| READ COMMIТTED | Нет | Да | Да | Нет |
| REPEATABLE READ | Нет | Нет | Да | Нет|
| SERIALIZABLE | Нет | Нет | Нет | Да |

##### Взаимоблокировки

Взаимоблокировка возникает тогда, когда две и более транзакции взаимно удерживают и запрашивают блокировку одних и тех же ресурсов, создавая циклическую зависимость.
Такие состояния наблюдаются и в том случае, если транзакции пытаются заблокировать ресурсы в разном порядке. Они могут возникнуть, когда несколько транзакций блокируют одни и те же ресурсы.

Нельзя справиться с взаимоблокировками без отката одной из транзакций, частичного либо полного.

##### Ведение журнала транзакций

Ведение журнала помогает сделать транзакции более эффективными. Вместо обновления таблиц на диске после каждого изменения подсистема хранения данных может изменить находящуюся в памяти копию данных. Это происходит очень быстро. Затем подсистема хранения запишет сведения об изменениях в журнал транзакции, который хранится на диске и поэтому долговечен. Это тоже довольно быстрая операция, поскольку добавление событий в журнал сводится к операции последовательного ввода/вывода в пределах ограниченной области диска вместо случайного ввода/вывода в разных местах. Позже процесс обновит таблицу на диске. Таким образом, большинство подсистем хранения данных, которые используют этот метод (упреждающую запись в журнал), дважды сохраняют изменения на диске. Если сбой произойдет после внесения записи в журнал транзакции, но до обновления самих данных, подсистема хранения может восстановить изменения после перезагрузки сервера.

### ДОБАВЛЕНИЕ, УПРАВЛЕНИЕ И УДАЛЕНИЕ ПОЛЬЗОВАТЕЛЕЙ

Документация: [6.2.8 Adding Accounts, Assigning Privileges, and Dropping Accounts](https://dev.mysql.com/doc/refman/8.0/en/creating-accounts.html)

#### Создание пользователя

```mysql
CREATE USER 'user_name'@'localhost'
	IDENTIFIED BY 'password' ## Пароль для пользователя
	GRANT ALL ## Выставление прав
	ON *.*
	TO 'user_name'@'localhost'
	WITH GRANT OPTION;
```

#### DDL, DML

Инструкции в SQL можно разделить на 2 большие группы DDL и DML

DDL - это инструкции создания/ удаления/ редактирования схем и таблиц

DML - это инструкции создания/ удаления/ редактирования / извлечения данных из таблиц

### КЛЮЧЕВЫЕ СЛОВА

#### SERIAL

`SERIAL` это специальный псевдоним для `BIGINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE`

### СОЗДАНИЕ ДАМПА

Дамп БД может понадобиться в следующих ситуациях: backup БД, перенос БД на другой сервер

Для этого создается специальный dump файл - текстовый файл, который содержит инструкции для восстановдления БД

Для удобства в файле [.my.cnf](КОНФИГУРАЦИОННЫЙ ФАЙЛ .my.cnf) изменим название секции [MYSQL] -> [client]
теперь данные этой секции распространяются на все утилиты

Создание: 

```bash
mysqldump mysql; # в качестве параметра имя БД
```

Восстановление:

```bash
mysql <db_name> < dump.sql # с помощью утилиты mysql выбираем БД и направляем туда содержимое файла с дампом
```



#### ДВИЖКИ ТАБЛИЦ MYSQL

Посмотреть движки и их описание можно командой 

``` SHOW ENGINES```

Пример ответа : 

| Engine    | Support | Comment                        | Transactions | XA   | Savepoints |
| --------- | ------- | ------------------------------ | ------------ | ---- | ---------- |
| FEDERATED | NO      | Federated MySQL storage engine | NULL         | NULL | NULL       |
| MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         |
| InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        |
| PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         |
| MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         |
| MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         |
| BLACKHOLE          | YES     | /dev/null storage engine (anything you write to it disappears) | NO           | NO   | NO         |
| CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         |
| ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         |



Самыми популярными являются: 

##### MyIsam

##### InnoDB



#### ИНДЕКСЫ И КЛЮЧИ

Идея индекса - создать копию столбца, которая будет поддерживаться в сортированном состоянии. В качестве минуса - перестроение индекса, всякий раз, когда добавляется новое значение.

##### Как происходит чтение данных с диска.

На накопителе нет понятия файл - есть блок. Обычно один файл занимает несколько блоков. Каждый блок знает какой блок идет после него. Файл делится на куски и каждый кусок сохраняется в пустой блок. 

```
| block | -> | block |-> | block |
| block | -> | block |
```

При чтении файла, мы по очереди проходимся по всем блокам и собираем файл из кусков. Блоки одного файла могут быть раскиданы по диску (фрагментация). Тогда чтение файла замедляется т.к. понадобится прыгать к разным участкам накопителя.

Когда мы ищем что-то внутри файла, нам понадобится пройтись по всем блокам, в которых он сохранен. Если файл очень большой, то и количество блоков будет значительным. Необходимость перепрыгивать с блока на блок, которые могут находится в разных местах, сильно замедлит поиск данных.

##### Поиск данных в MySQL

Таблицы MySQL - это обычные файлы. Например есть такой запрос

 ```sql
SELECT * FROM users WHERE age = 29
 ```

MySQL открывает файл, где зранятся данные из таблицы **users**.

А дальше начинает перебирать весь файл, чтобы найти нужные записи.

Кроме этого, MySQL будет сравнивать данные в **каждой строке таблицы** со значением в запросе. Допустим работа ведется с таблицей, в которой есть 10 записей. Тогда MySQL прочитает все 10 записей, сравнит кологну age каждой из них со значением 29 и отберет только подходящие данные

Таким образом можно выделить 2 проблемы при чтении данных:

1. Низкая скорость чтения файлов из-за расположения блоков в разных частях диска (фрагментация)
2. Большое количество операций сравнения для поиска нужных данных.

#####  Сортировка данных

Представи, что мы отсортировали наши 10 записей по убыванию. Тогда используя алгоритм [бинарного поиска](https://en.wikipedia.org/wiki/Binary_search_algorithm), мы могли бы максимум за 4 операции отобрать нужные значения. Кроме того, мы сэкономили бы на чтении ненужных записей.

**Индекс** - это и есть отсортированный набор значений. В MySQL индексы всегда строятся для какой-то конкретной колонки.

##### Виды индексов

1. ###### Обычный индекс

   

2. ###### Уникальный индекс

3. ###### Первичный ключ

   **PRIMARY KEY** - устанавливает на таблицу PK. 

4. ###### Составной индекс

5. ###### Кластерный индекс

6. ###### Покрывающий индекс

7. ###### Полнотекстовый индекс

##### Структура индексов

1. **b-tree**
2. **hash**



### СЛОЖНЫЕ ЗАПРОСЫ

#### UNION

Оператор ``` SELECT ``` в качестве результата возвращает таблицу, если форматы таблиц у двух ```SELECT``` совпадают, то для объединения результатов, можно использовать ```UNION```

Создадим две таблицы ```catalogs``` и  ``` rubrics```

```sql
CREATE TABLE rubrics (
-> id SERIAL PRIMARY KEY,
-> name VARCHAR(255)
-> );

CREATE TABLE catalogs (
-> id SERIAL PRIMARY KEY,
-> name VARCHAR(255)
-> );
```

Заполним их данными

```sql
INSERT INTO rubrics
-> (id, name) VALUES
-> (null, 'CPUs'),
-> (null, 'Motherboards'),
-> (null, 'Graphics adapters')
-> ;

INSERT INTO catalogs
-> (id, null) VALUES
-> (null, 'RAM'),
-> (null, 'Motherboards')
->;
```

Данные таблицы схожи по структуре, значит мы можем применить ``` UNION ```

```sql
SELECT name FROM rubrics
UNION
SELECT name FROM catalogs
ORDER BY name
```

Получаем результирующую таблицу с объединенными результатами

```sql
+-------------------+
| name 				|
+-------------------+
| CPUs			    |
| Graphics adapters |
| Motherboards		|
| RAM				|
+-------------------+
```

Обратим внимание что т.к. значение 'Motherboards' присутствовало в двух таблицах, оно было объединено.

Для того чтобы предотвратить такое помедение можно использовать ключевое слово ``` ALL ``` после оператора ``` UNION```

В этом случае результат будет выглядеть как:

```sql
+-------------------+
| name 				|
+-------------------+
| CPUs			    |
| Graphics adapters |
| Motherboards		|
| Motherboards		|
| RAM				|
+-------------------+
```

Есть особенности в работе ORDER BY  и  LIMIT  в UNION запросах. Сначала будет выполнен UNION и только потом, на результирующую таблицу будут применены ORDER BY или LIMIT.

Нет четкого условия, что таблицы должны быть одинаковыми.

Есть требования к результатам SELECT чтобы количество столбцов и их тип совпадали.

Следует иметь ввиду, что первый SELECT определяет название столбцов.

В UNION могут содержаться больше 2-х таблиц.

UNION это довольно медленная операция, т.к. временная таблица будет создана во временном файле.

####  ВЛОЖЕННЫЕ ЗАПРОСЫ

Вложенный запрос позволяет использовать результат, возвращаемый в основном запросе.

<SUBQUERY> -  метка показывает места, где могут содержаться вложенные запросы

```sql
SELECT
	id,
	(<SUBQUERY>)
FROM
	(<SUBQUERY>)
WHERE
	(<SUBQUERY>)
GROUP BY
	id
HAVING
	(<SUBQUERY>)
```

#### IN



#### ANY



#### SOME



#### JOIN



##### JOIN



##### LEFT JOIN



##### RIGHT JOIN



##### OUTER JOIN



##  Полезное

### Как пользоваться REGEXP

Документация по [REGEXP](https://dev.mysql.com/doc/refman/8.0/en/regexp.html)

Основные команды: 

```mysql
REGEXP - строки удволетворяющие паттерну
NOT REGEXP - обратное от REGEXP
```

Синтаксис :

```mysql
SELECT 'a' REGEXP '^[a-d]';
```

### Архитектура MySQL

#### Логическая архитектура сервера MySQL


						 Клиенты
						| | | | |
						V V V V V
	+-------------------------------------------+
	| 	+--------------------------+			|
	| 	| Обработка соединений /   | 			|
	| 	| 	потоков                |			|
	| 	+--------------------------+			|
	|		|					|				|
	|		V					V				|
	| +--------------+		+----------------+	|
	| | Кэш запросов |  <-- | Синтаксический |	|
	| +--------------+  	| анализатор	 |	|
	|                       +----------------+	|
	|								|		    |
	|								V			|
	| +---------------------------------------+ |
	| |  Оптимизатор						  |	|
	| +---------------------------------------+ |
	+-------------------------------------------+
	
					Подсистемы хранения
### РЕПЛИКАЦИЯ



### ШАРДИНГ

##### Вертикальный шардинг

##### Горизонтальный шардинг



### СПИСОК ИСПОЛЬЗОВАННЫХ МАТЕРИАЛОВ: 

* [Официальная документация MySQL]()
* [Индексы в MySQL](https://ruhighload.com/Индексы+в+mysql) - https://ruhighload.com/Индексы+в+mysql
* Базы данных. Интерактивный курс - Geekbrains
* Бэрон Шварц, Петр Зайцев, Вадим Ткаченко - MySQL по максимуму 3-е издание